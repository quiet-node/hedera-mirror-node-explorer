// noinspection DuplicatedCode

/*-
 *
 * Hedera Mirror Node Explorer
 *
 * Copyright (C) 2021 - 2023 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import {Ref, ref} from "vue";
import {flushPromises} from "@vue/test-utils";
import MockAdapter from "axios-mock-adapter";
import axios from "axios";
import {ContractAnalyzer} from "@/utils/ContractAnalyzer";
import {SAMPLE_CONTRACT} from "../Mocks";
import {SolcMetadata} from "@/utils/solc/SolcMetadata";
import {CacheUtils} from "@/utils/cache/CacheUtils";

describe("FunctionCallAnalyzer.spec.ts", () => {

    beforeEach(() => CacheUtils.clearAll())

    test("unverified custom contract", async () => {

        const matcher1 = "api/v1/contracts/" + SAMPLE_CONTRACT.contract_id
        const mock = new MockAdapter(axios);
        mock.onGet(matcher1).reply(200, SAMPLE_CONTRACT)

        // 1) new
        const contractId: Ref<string|null> = ref(null)
        const contractAnalyzer = new ContractAnalyzer(contractId)
        expect(contractAnalyzer.contractId.value).toBeNull()
        expect(contractAnalyzer.sourceFileName.value).toBeNull()
        expect(contractAnalyzer.contractName.value).toBeNull()
        expect(contractAnalyzer.fullMatch.value).toBeNull()
        expect(contractAnalyzer.sourcifyURL.value).toBeUndefined()
        expect(contractAnalyzer.interface.value).toBeNull()

        // 2) mount
        contractAnalyzer.mount()
        await flushPromises()
        expect(contractAnalyzer.contractId.value).toBeNull()
        expect(contractAnalyzer.sourceFileName.value).toBeNull()
        expect(contractAnalyzer.contractName.value).toBeNull()
        expect(contractAnalyzer.fullMatch.value).toBeNull()
        expect(contractAnalyzer.sourcifyURL.value).toBeUndefined()
        expect(contractAnalyzer.interface.value).toBeNull()

        // 3) setup
        contractId.value = SAMPLE_CONTRACT.contract_id
        await flushPromises()
        expect(contractAnalyzer.contractId.value).toBe(SAMPLE_CONTRACT.contract_id)
        expect(contractAnalyzer.sourceFileName.value).toBeNull()
        expect(contractAnalyzer.contractName.value).toBeNull()
        expect(contractAnalyzer.fullMatch.value).toBeNull()
        expect(contractAnalyzer.sourcifyURL.value).toBeUndefined()
        expect(contractAnalyzer.interface.value).toBeNull()

        // 4) unmount
        contractAnalyzer.unmount()
        await flushPromises()
        expect(contractAnalyzer.contractId.value).toBe(SAMPLE_CONTRACT.contract_id)
        expect(contractAnalyzer.sourceFileName.value).toBeNull()
        expect(contractAnalyzer.contractName.value).toBeNull()
        expect(contractAnalyzer.fullMatch.value).toBeNull()
        expect(contractAnalyzer.sourcifyURL.value).toBeUndefined()
        expect(contractAnalyzer.interface.value).toBeNull()

    })

    test("verified custom contract", async () => {

        const mock = new MockAdapter(axios);

        const matcher1 = "api/v1/contracts/" + SAMPLE_CONTRACT.contract_id
        mock.onGet(matcher1).reply(200, SAMPLE_CONTRACT)

        const matcher2 = "https://repo.sourcify.dev/contracts/full_match/296/" + SAMPLE_CONTRACT.evm_address + "/metadata.json"
        mock.onGet(matcher2).reply(200, SAMPLE_METADATA)

        // 1) new
        const contractId: Ref<string|null> = ref(null)
        const contractAnalyzer = new ContractAnalyzer(contractId)
        expect(contractAnalyzer.contractId.value).toBeNull()
        expect(contractAnalyzer.sourceFileName.value).toBeNull()
        expect(contractAnalyzer.contractName.value).toBeNull()
        expect(contractAnalyzer.fullMatch.value).toBeNull()
        expect(contractAnalyzer.sourcifyURL.value).toBeUndefined()
        expect(contractAnalyzer.interface.value).toBeNull()

        // 2) mount
        contractAnalyzer.mount()
        await flushPromises()
        expect(contractAnalyzer.contractId.value).toBeNull()
        expect(contractAnalyzer.sourceFileName.value).toBeNull()
        expect(contractAnalyzer.contractName.value).toBeNull()
        expect(contractAnalyzer.fullMatch.value).toBeNull()
        expect(contractAnalyzer.sourcifyURL.value).toBeUndefined()
        expect(contractAnalyzer.interface.value).toBeNull()

        // 3) setup
        contractId.value = SAMPLE_CONTRACT.contract_id
        await flushPromises()
        expect(contractAnalyzer.contractId.value).toBe(SAMPLE_CONTRACT.contract_id)
        expect(contractAnalyzer.sourceFileName.value).toBe("contracts/Community.sol")
        expect(contractAnalyzer.contractName.value).toBe("Community")
        expect(contractAnalyzer.fullMatch.value).toBeTruthy()
        expect(contractAnalyzer.sourcifyURL.value).toBe("https://repo.sourcify.dev/contracts/full_match/296/0x00000000000000000000000000000000000b70cf")
        expect(contractAnalyzer.interface.value).not.toBeNull()

        // 4) unmount
        contractAnalyzer.unmount()
        await flushPromises()
        expect(contractAnalyzer.contractId.value).toBe(SAMPLE_CONTRACT.contract_id)
        expect(contractAnalyzer.sourceFileName.value).toBeNull()
        expect(contractAnalyzer.contractName.value).toBeNull()
        expect(contractAnalyzer.fullMatch.value).toBeNull()
        expect(contractAnalyzer.sourcifyURL.value).toBeUndefined()
        expect(contractAnalyzer.interface.value).toBeNull()

    })


})



const SAMPLE_METADATA: SolcMetadata = {
    "compiler": {
        "version": "0.8.6+commit.11564f7e"
    },
    "language": "Solidity",
    "output": {
        "abi": [
            {
                "inputs": [
                    {
                        "internalType": "bytes",
                        "name": "_data",
                        "type": "bytes"
                    },
                    {
                        "internalType": "bytes",
                        "name": "_signature",
                        "type": "bytes"
                    }
                ],
                "name": "addMember",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "adminLock",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "communities",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    },
                    {
                        "internalType": "contract IToken20",
                        "name": "currency",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "memberCount",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "projectCount",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "communityCount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_communityID",
                        "type": "uint256"
                    }
                ],
                "name": "communityDetails",
                "outputs": [
                    {
                        "internalType": "address[]",
                        "name": "",
                        "type": "address[]"
                    },
                    {
                        "internalType": "address[]",
                        "name": "",
                        "type": "address[]"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "",
                        "type": "uint256[]"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "",
                        "type": "uint256[]"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "",
                        "type": "uint256[]"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "",
                        "type": "uint256[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes",
                        "name": "_hash",
                        "type": "bytes"
                    },
                    {
                        "internalType": "address",
                        "name": "_currency",
                        "type": "address"
                    }
                ],
                "name": "createCommunity",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "homeFiInstance",
                "outputs": [
                    {
                        "internalType": "contract IHomeFi",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_homeFi",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "_eventsContract",
                        "type": "address"
                    }
                ],
                "name": "initialize",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_communityID",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "_project",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_investment",
                        "type": "uint256"
                    }
                ],
                "name": "investInProject",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_forwarder",
                        "type": "address"
                    }
                ],
                "name": "isTrustedForwarder",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_communityID",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "_project",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "_projectDetails",
                        "type": "uint256[]"
                    }
                ],
                "name": "publishProject",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_communityID",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "_project",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_repayAmount",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bytes",
                        "name": "_details",
                        "type": "bytes"
                    }
                ],
                "name": "reduceDebt",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_communityID",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "_project",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "_investor",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_repayAmount",
                        "type": "uint256"
                    }
                ],
                "name": "repayInvestor",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_communityID",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "_project",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "_investor",
                        "type": "address"
                    }
                ],
                "name": "returnToInvestor",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "_return",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_invested",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bool",
                        "name": "_locked",
                        "type": "bool"
                    }
                ],
                "name": "setAdminLock",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_communityID",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "_project",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "_to",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_amount",
                        "type": "uint256"
                    }
                ],
                "name": "transferFraction",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_communityID",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bytes",
                        "name": "_hash",
                        "type": "bytes"
                    }
                ],
                "name": "updateCommunityHash",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ],
        "devdoc": {
            "kind": "dev",
            "methods": {
                "addMember(bytes,bytes)": {
                    "params": {
                        "_data": "bytes - data encoded: - _communityID community count - _memberAddr member address to add",
                        "_signature": "bytes - _data signed by the community owner"
                    }
                },
                "communityDetails(uint256)": {
                    "params": {
                        "_communityID": "uint256 - the uuid (serial) of the community to query"
                    },
                    "returns": {
                        "_0": "address[] - array of all member accounts",
                        "_1": "address[] - array of all projects the community can invest in",
                        "_2": "uint256[] - array of interest rates with index relating to _projects",
                        "_3": "uint256[] - array of starting date of debt repayments with index relating to _projects",
                        "_4": "uint256[] - array of final date of debt repayment with index relating to _projects (double APR after)",
                        "_5": "uint256[] - array of amounts needed by projects before investment completes with index relating to _projects"
                    }
                },
                "createCommunity(bytes,address)": {
                    "params": {
                        "_currency": "address - the currency accepted for creating new HomeFi debt tokens",
                        "_hash": "bytes - the identifying hash of the community"
                    }
                },
                "isTrustedForwarder(address)": {
                    "params": {
                        "_forwarder": "address of contract forwarding meta tx"
                    }
                },
                "publishProject(uint256,address,uint256[])": {
                    "details": "modifier onlyBuildermodifier checkMember",
                    "params": {
                        "_communityID": "uint256 - the the uuid (serial) of the community being published to",
                        "_project": "address - the project contract being added to the community for investment",
                        "_projectDetails": "uint256[] - integer metadata for project  - [0] = APR; [1]: Min repayment timestamp; [2]: Max repayment timestamp; [3]: investment needed  - NOTE: APR is in per thousand. Ex: 5% interest => APR = 50"
                    }
                },
                "reduceDebt(uint256,address,uint256,bytes)": {
                    "details": "modifier nonReentrant",
                    "params": {
                        "_communityID": "uint256 - the the uuid of the community",
                        "_details": "bytes - some details on why debt is reduced (off chain documents or images)",
                        "_project": "address - the address of the deployed project contract",
                        "_repayAmount": "uint256 - the amount of funds repaid to the investor, in the project currency"
                    }
                },
                "repayInvestor(uint256,address,address,uint256)": {
                    "details": "modifier onlyBuildermodifier nonReentrantmodifier nonZero(_investor)users MUST call approve on respective token contracts for the community contract firstIf the project's currency is native, then user can also pay in the native currencyby passing msg.value, it will be converted in to wrapped tokens internally",
                    "params": {
                        "_communityID": "uint256 - the the uuid of the community",
                        "_investor": "address - the address of the investor to repay + interest",
                        "_project": "address - the address of the deployed project contract",
                        "_repayAmount": "uint256 - the amount of funds repaid to the investor, in the project currency"
                    }
                },
                "transferFraction(uint256,address,address,uint256)": {
                    "details": "modifier nonReentrantmodifier nonZero(_to)",
                    "params": {
                        "_amount": "amount of debt token he want to transfer",
                        "_communityID": "uint256 - the the uuid (serial) of the community",
                        "_project": "address - the address of the deployed project contract",
                        "_to": "address - the address receiving ownership of the specified investments"
                    },
                    "returns": {
                        "_0": "bool - will always return true if does not revert during execution"
                    }
                },
                "updateCommunityHash(uint256,bytes)": {
                    "params": {
                        "_communityID": "uint256 - the the uuid of the community",
                        "_hash": "bytes - the new hash to update the community hash to"
                    }
                }
            },
            "version": 1
        },
        "userdoc": {
            "kind": "user",
            "methods": {
                "addMember(bytes,bytes)": {
                    "notice": "Add a new member to an investment communityComprises of both request to join and join."
                },
                "communityDetails(uint256)": {
                    "notice": "Return all info about a specific community"
                },
                "createCommunity(bytes,address)": {
                    "notice": "Create a new investment community on HomeFi"
                },
                "initialize(address,address)": {
                    "notice": "CONSTRUCTOR ///"
                },
                "isTrustedForwarder(address)": {
                    "notice": "checks trustedForwarder on HomeFi contract"
                },
                "publishProject(uint256,address,uint256[])": {
                    "notice": "Add a new project to an investment community"
                },
                "reduceDebt(uint256,address,uint256,bytes)": {
                    "notice": "As an investor, if the repayment was done off platform then can mark their debt paid"
                },
                "repayInvestor(uint256,address,address,uint256)": {
                    "notice": "As a builder, repay an investor for their investment with interestthis is where funds flow out of contracts for investors"
                },
                "returnToInvestor(uint256,address,address)": {
                    "notice": "VIEWABLE FUNCTIONS ///"
                },
                "setAdminLock(bool)": {
                    "notice": "MUTABLE FUNCTIONS ///"
                },
                "transferFraction(uint256,address,address,uint256)": {
                    "notice": "Transfer ownership of investments from one user to anotherin practice transfer debt erc20 tokens + update references in custom nft logic"
                },
                "updateCommunityHash(uint256,bytes)": {
                    "notice": "Update the internal identifying hash of a communityIDK why exactly this exists yet"
                }
            },
            "notice": "Module for coordinating investment groups on HomeFi protocol",
            "version": 1
        }
    },
    "settings": {
        "compilationTarget": {
            "contracts/Community.sol": "Community"
        },
        "evmVersion": "berlin",
        "libraries": {},
        "metadata": {
            "bytecodeHash": "ipfs",
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "remappings": []
    },
    "sources": {
        "@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n */\nabstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {\n    address private _trustedForwarder;\n\n    function __ERC2771Context_init(address trustedForwarder) internal initializer {\n        __Context_init_unchained();\n        __ERC2771Context_init_unchained(trustedForwarder);\n    }\n\n    function __ERC2771Context_init_unchained(address trustedForwarder) internal initializer {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n    uint256[49] private __gap;\n}\n",
            "keccak256": "0x16ab179d5b3cdc3d8b1d3ab8314d4e93c5e53c1d4a6b04060e6be7084752a1fc",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n",
            "keccak256": "0x8b2abd85d0ece7e866e100e9d47ca9cbec93c87cf71a8d267b2b93eb81f7d5e9",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n",
            "keccak256": "0x89fa60d14355f7ae06af11e28fce2bb90c5c6186645d681a30e1b36234a4c210",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n",
            "keccak256": "0xf449ca0a763d4b1b4462cf8706857074492f324020a2b9d099181b5383055ad3",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n",
            "keccak256": "0x6795c369a4eefa78468e38966f7851fbc2dda5e5b9ccd3fa2b45970e2e4d3abd",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n",
            "keccak256": "0xc7d7fe7d5ed5068742927e37b400591153dbe8526cd942cfcf5dbb971ba5e8e2",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n    uint256[44] private __gap;\n}\n",
            "keccak256": "0x56f89378fca44345fe8de632c70311052c39d64a7a710513316676d343380e68",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n",
            "keccak256": "0x3d03f5cb8b9f17b75c3b6eb4921b1fe7b87ed77cf0c8638496eee5183a5101e0",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n",
            "keccak256": "0xfbb3ca7272af58dc245a20e91a1f68481ee04706fa3fe46d184000efc21f4bad",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, ERC721Upgradeable {\n    function __ERC721URIStorage_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721URIStorage_init_unchained();\n    }\n\n    function __ERC721URIStorage_init_unchained() internal initializer {\n    }\n    using StringsUpgradeable for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n    uint256[49] private __gap;\n}\n",
            "keccak256": "0x41695fa16b1c8b9e8fc92315f7413ce2f5d67782290b6d785fef7143932d54a1",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n",
            "keccak256": "0x6dd43e44dbaad99d1863be7f2837085f361efdcb1fde5a9bf84c4efa07f89ed3",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n",
            "keccak256": "0x946f08c0a132c5877d458d7af7956da60607f20a5c03dd75760708c848aae6b7",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n",
            "keccak256": "0x062b5a0f7cc6b0528fa350033759f3a15ba42afb57423d7c593753860f2c82e0",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n",
            "keccak256": "0xc7af08df3d3e818ce36f95aa879c13245772fed21b553e6033292ea4edc2a9f3",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n",
            "keccak256": "0x17c9c5d2d6b56527215ee7b3da6dde66b6f23f1b3d5c66cc436e753ef349a97a",
            "license": "MIT"
        },
        "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n",
            "keccak256": "0x1c4860acd323e34a67b3e97faab9aaa55fe8e92b1dcf08b5f47f3468d58ce75c",
            "license": "MIT"
        },
        "@openzeppelin/contracts/metatx/MinimalForwarder.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/ECDSA.sol\";\nimport \"../utils/cryptography/draft-EIP712.sol\";\n\n/**\n * @dev Simple minimal forwarder to be used together with an ERC2771 compatible contract. See {ERC2771Context}.\n */\ncontract MinimalForwarder is EIP712 {\n    using ECDSA for bytes32;\n\n    struct ForwardRequest {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint256 nonce;\n        bytes data;\n    }\n\n    bytes32 private constant _TYPEHASH =\n        keccak256(\"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)\");\n\n    mapping(address => uint256) private _nonces;\n\n    constructor() EIP712(\"MinimalForwarder\", \"0.0.1\") {}\n\n    function getNonce(address from) public view returns (uint256) {\n        return _nonces[from];\n    }\n\n    function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\n        address signer = _hashTypedDataV4(\n            keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\n        ).recover(signature);\n        return _nonces[req.from] == req.nonce && signer == req.from;\n    }\n\n    function execute(ForwardRequest calldata req, bytes calldata signature)\n        public\n        payable\n        returns (bool, bytes memory)\n    {\n        require(verify(req, signature), \"MinimalForwarder: signature does not match request\");\n        _nonces[req.from] = req.nonce + 1;\n\n        (bool success, bytes memory returndata) = req.to.call{gas: req.gas, value: req.value}(\n            abi.encodePacked(req.data, req.from)\n        );\n        // Validate that the relayer has sent enough gas for the call.\n        // See https://ronan.eth.link/blog/ethereum-gas-dangers/\n        assert(gasleft() > req.gas / 63);\n\n        return (success, returndata);\n    }\n}\n",
            "keccak256": "0xf7ba4a4a7c722c5e739d2ac3e7c2c3a7d6ebd8eae144d36612d4821db2d608db",
            "license": "MIT"
        },
        "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n",
            "keccak256": "0xbc991a1cf357ce19480831a40792c814238a3b5458134703682abd8aa39719fb",
            "license": "MIT"
        },
        "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n",
            "keccak256": "0xba18d725602452307e5b278ed4566616c63792d89f3a0388a6f285428c26e681",
            "license": "MIT"
        },
        "contracts/Community.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"./interfaces/ICommunity.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * Module for coordinating investment groups on HomeFi protocol\n */\ncontract Community is ICommunity {\n    using SafeERC20Upgradeable for IToken20;\n\n    /// CONSTRUCTOR ///\n\n    function initialize(address _homeFi, address _eventsContract)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n        nonZero(_eventsContract)\n    {\n        homeFiInstance = IHomeFi(_homeFi);\n        eventsInstance = IEvents(_eventsContract);\n        wrappedNativeCurrency = homeFiInstance.wrappedNativeCurrency();\n        tokenCurrency1 = homeFiInstance.tokenCurrency1();\n        tokenCurrency2 = homeFiInstance.tokenCurrency2();\n        adminLock = true;\n    }\n\n    /// MUTABLE FUNCTIONS ///\n\n    function setAdminLock(bool _locked) external override {\n        require(_msgSender() == homeFiInstance.admin(), \"Community::!admin\");\n        adminLock = _locked;\n        eventsInstance.adminLock(_locked);\n    }\n\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n    {\n        require(\n            !adminLock || _msgSender() == homeFiInstance.admin(),\n            \"Community::!admin\"\n        );\n        homeFiInstance.validCurrency(_currency);\n        communities[communityCount].owner = _msgSender();\n        communities[communityCount].currency = IToken20(_currency);\n        communities[communityCount].memberCount = 1;\n        communities[communityCount].members[0] = _msgSender();\n        communities[communityCount].isMember[_msgSender()] = true;\n        communityCount++;\n        eventsInstance.communityAdded(\n            communityCount - 1,\n            _msgSender(),\n            _currency,\n            _hash\n        );\n    }\n\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        require(\n            communities[_communityID].owner == _msgSender(),\n            \"Community::!Owner\"\n        );\n        eventsInstance.updateCommunityHash(_communityID, _hash);\n    }\n\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        bytes32 _hash = keccak256(_data);\n        address _a1 = SignatureDecoder.recoverKey(_hash, _signature, 0);\n        address _a2 = SignatureDecoder.recoverKey(_hash, _signature, 1);\n        address _ownerRecovered;\n        address _memberToAdd = address(0);\n        (uint256 _communityID, address _newMemberAddr) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n        if (_a1 == communities[_communityID].owner) {\n            _ownerRecovered = _a1;\n            _memberToAdd = _a2;\n        } else if (_a2 == communities[_communityID].owner) {\n            _ownerRecovered = _a2;\n            _memberToAdd = _a1;\n        } else {\n            revert(\"Community::!Admin\");\n        }\n        require(\n            !communities[_communityID].isMember[_memberToAdd],\n            \"Community::Member Exists\"\n        );\n        require(_memberToAdd == _newMemberAddr, \"Community::!Signature\");\n        uint256 _communityCount = communities[_communityID].memberCount;\n        communities[_communityID].memberCount = _communityCount + 1;\n        communities[_communityID].members[_communityCount] = _memberToAdd;\n        communities[_communityID].isMember[_memberToAdd] = true;\n        eventsInstance.memberAdded(_communityID, _memberToAdd);\n    }\n\n    function publishProject(\n        uint256 _communityID,\n        address _project,\n        uint256[] calldata _projectDetails\n    ) external virtual override checkMember(_communityID, _msgSender()) {\n        require(\n            homeFiInstance.projectExist((_project)),\n            \"Community::Project !Exists\"\n        );\n        require(\n            !communities[_communityID].projectDetails[_project].exists,\n            \"Community::Published\"\n        );\n        IProject _projectInstance = IProject(_project);\n        require(\n            _projectInstance.currency() == communities[_communityID].currency,\n            \"Community::!Currency\"\n        );\n        require(\n            _msgSender() == _projectInstance.builder(),\n            \"Community::!Builder\"\n        );\n        require(_projectDetails.length == 4, \"Community::Details !OK\");\n        uint256 _projectCount = communities[_communityID].projectCount;\n        communities[_communityID].projectCount = _projectCount + 1;\n        communities[_communityID].projects[_projectCount] = _project;\n        communities[_communityID].projectDetails[_project].exists = true;\n        communities[_communityID]\n            .projectDetails[_project]\n            .apr = _projectDetails[0];\n        communities[_communityID]\n            .projectDetails[_project]\n            .repaymentStartDate = _projectDetails[1];\n        communities[_communityID]\n            .projectDetails[_project]\n            .repaymentEndDate = _projectDetails[2];\n        communities[_communityID]\n            .projectDetails[_project]\n            .investmentNeeded = _projectDetails[3];\n        eventsInstance.projectPublished(\n            _communityID,\n            _project,\n            _projectDetails[0]\n        );\n    }\n\n    function investInProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _investment\n    )\n        external\n        payable\n        virtual\n        override\n        nonReentrant\n        checkMember(_communityID, _msgSender())\n    {\n        require(\n            communities[_communityID].projectDetails[_project].exists,\n            \"Community::Project !Exists\"\n        );\n        require(\n            communities[_communityID]\n                .projectDetails[_project]\n                .repaymentStartDate > block.timestamp,\n            \"Community::Investment Closed\"\n        );\n        IProject _projectInstance = IProject(_project);\n        require(\n            _msgSender() != _projectInstance.builder(),\n            \"Community::Builder\"\n        );\n        uint256 _investmentNeeded = communities[_communityID]\n            .projectDetails[_project]\n            .investmentNeeded;\n\n        uint256 _investorFee = (_investment * _projectInstance.investorFee()) /\n            1000;\n        uint256 _amountInvested = _investment - _investorFee;\n        require(\n            _amountInvested <= _investmentNeeded,\n            \"Community::Investment>needed\"\n        );\n        IToken20 _currency = communities[_communityID].currency;\n        address _treasury = homeFiInstance.treasury();\n\n        if (\n            address(_currency) == homeFiInstance.wrappedNativeCurrency() &&\n            msg.value > 0\n        ) {\n            require(msg.value == _investment, \"Community::!msg.value\");\n            IWrapped(address(_currency)).deposit{value: msg.value}();\n            _currency.safeTransfer(_treasury, _investorFee);\n            _currency.safeTransfer(_project, _amountInvested);\n        } else {\n            require(msg.value == 0, \"Community::msg.value!0\");\n            _currency.safeTransferFrom(_msgSender(), _treasury, _investorFee);\n            _currency.safeTransferFrom(_msgSender(), _project, _amountInvested);\n        }\n        _projectInstance.investInProject(_amountInvested);\n\n        IToken20 _wrappedToken = IToken20(\n            homeFiInstance.wrappedToken(address(_currency))\n        );\n        _wrappedToken.mint(_msgSender(), _investment);\n        communities[_communityID].projectDetails[_project].investmentNeeded =\n            _investmentNeeded -\n            _amountInvested;\n\n        if (\n            communities[_communityID]\n                .projectDetails[_project]\n                .investmentDetails[_msgSender()]\n                .investedAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _msgSender(), _wrappedToken);\n        }\n\n        communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_msgSender()]\n            .investedAmount += _investment;\n\n        communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_msgSender()]\n            .investmentTimestamp = block.timestamp;\n\n        eventsInstance.investorInvested(\n            _communityID,\n            _project,\n            _msgSender(),\n            _investment\n        );\n    }\n\n    function repayInvestor(\n        uint256 _communityID,\n        address _project,\n        address _investor,\n        uint256 _repayAmount\n    ) external payable override nonReentrant nonZero(_investor) {\n        require(\n            communities[_communityID].projectDetails[_project].exists,\n            \"Community::Project !Exists\"\n        );\n        IProject _projectInstance = IProject(_project);\n        require(\n            _msgSender() == _projectInstance.builder(),\n            \"Community::!Builder\"\n        );\n        require(\n            communities[_communityID]\n                .projectDetails[_project]\n                .repaymentStartDate <= block.timestamp,\n            \"Community::Repayment !started\"\n        );\n\n        IToken20 _currency = communities[_communityID].currency;\n        IToken20 _wrappedToken = IToken20(\n            homeFiInstance.wrappedToken(address(_currency))\n        );\n\n        claimInterest(_communityID, _project, _investor, _wrappedToken);\n\n        uint256 _amountToReturn = communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_investor]\n            .investedAmount;\n\n        require(_repayAmount <= _amountToReturn, \"Community::!Liquid\");\n        communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_investor]\n            .investedAmount = _amountToReturn - _repayAmount;\n        _wrappedToken.burn(_investor, _repayAmount);\n        if (\n            address(_currency) == homeFiInstance.wrappedNativeCurrency() &&\n            msg.value > 0\n        ) {\n            require(msg.value == _repayAmount, \"Community::!msg.value\");\n            IWrapped(address(_currency)).deposit{value: msg.value}();\n            _currency.safeTransfer(_investor, _repayAmount);\n        } else {\n            _currency.safeTransferFrom(_msgSender(), _investor, _repayAmount);\n        }\n\n        eventsInstance.repayInvestor(\n            _communityID,\n            _project,\n            _investor,\n            _repayAmount\n        );\n    }\n\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes calldata _details\n    ) external virtual override nonReentrant {\n        require(\n            communities[_communityID].projectDetails[_project].exists,\n            \"Community::Project !Exists\"\n        );\n        require(\n            communities[_communityID]\n                .projectDetails[_project]\n                .repaymentStartDate <= block.timestamp,\n            \"Community::Repayment !started\"\n        );\n        address _investor = _msgSender();\n\n        IToken20 _currency = communities[_communityID].currency;\n        IToken20 _wrappedToken = IToken20(\n            homeFiInstance.wrappedToken(address(_currency))\n        );\n\n        claimInterest(_communityID, _project, _investor, _wrappedToken);\n\n        uint256 _amountToReturn = communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_investor]\n            .investedAmount;\n\n        require(_repayAmount <= _amountToReturn, \"Community::!Liquid\");\n        communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_investor]\n            .investedAmount = _amountToReturn - _repayAmount;\n        _wrappedToken.burn(_investor, _repayAmount);\n\n        eventsInstance.debtReduced(\n            _communityID,\n            _project,\n            _investor,\n            _repayAmount,\n            _details\n        );\n    }\n\n    function transferFraction(\n        uint256 _communityID,\n        address _project,\n        address _to,\n        uint256 _amount\n    )\n        external\n        override\n        nonReentrant\n        nonZero(_to)\n        checkMember(_communityID, _to)\n        returns (bool)\n    {\n        require(\n            communities[_communityID].projectDetails[_project].exists,\n            \"Community::Project !Exists\"\n        );\n        address _currency = address(communities[_communityID].currency);\n        IToken20 _wrappedToken = IToken20(\n            homeFiInstance.wrappedToken(_currency)\n        );\n        claimInterest(_communityID, _project, _msgSender(), _wrappedToken);\n        uint256 _userInvestedAmount = communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_msgSender()]\n            .investedAmount;\n        uint256 _toInvestedAmount = communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_to]\n            .investedAmount;\n        require(\n            _amount > 0 && _amount <= _userInvestedAmount,\n            \"Community::!Balance\"\n        );\n\n        if (_toInvestedAmount > 0) {\n            claimInterest(_communityID, _project, _to, _wrappedToken);\n        }\n\n        communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_msgSender()]\n            .investedAmount = _userInvestedAmount - _amount;\n        communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_to]\n            .investedAmount += _amount;\n\n        _wrappedToken.safeTransferFrom(_msgSender(), _to, _amount);\n\n        eventsInstance.debtTransferred(\n            _communityID,\n            _project,\n            _msgSender(),\n            _to,\n            _amount\n        );\n        return true;\n    }\n\n    /// VIEWABLE FUNCTIONS ///\n\n    function returnToInvestor(\n        uint256 _communityID,\n        address _project,\n        address _investor\n    ) public view override returns (uint256 _return, uint256 _invested) {\n        InvestmentDetails storage _investment = communities[_communityID]\n            .projectDetails[_project]\n            .investmentDetails[_investor];\n        uint256 _endDate = communities[_communityID]\n            .projectDetails[_project]\n            .repaymentEndDate;\n        uint256 _apr = communities[_communityID].projectDetails[_project].apr;\n        uint256 _dateOfInvestment = _investment.investmentTimestamp;\n        uint256 _investedAmount = _investment.investedAmount;\n\n        uint256 _noOfDays = (block.timestamp - _dateOfInvestment) / 86400; // 24*60*60\n        uint256 _noOfPenaltyDays = 0;\n        uint256 _daysSinceEnd = 0;\n        if (block.timestamp > _endDate) {\n            _daysSinceEnd = (block.timestamp - _endDate) / 86400;\n        }\n        if (_dateOfInvestment < _endDate) {\n            _noOfDays = _noOfDays - _daysSinceEnd;\n            _noOfPenaltyDays = _daysSinceEnd;\n        } else {\n            _noOfPenaltyDays = _noOfDays;\n            _noOfDays = 0;\n        }\n\n        uint256 _amountToReturn = _investedAmount +\n            ((_investedAmount * _apr * _noOfDays) / 365000) +\n            ((_investedAmount * 2 * _apr * _noOfPenaltyDays) / 365000); // double interest rate after endDate\n        return (_amountToReturn, _investedAmount);\n    }\n\n    function communityDetails(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address[] memory,\n            address[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        address[] memory _membersArray = new address[](\n            communities[_communityID].memberCount\n        );\n        address[] memory _projectArray = new address[](\n            communities[_communityID].projectCount\n        );\n        uint256[] memory _projectApr = new uint256[](\n            communities[_communityID].projectCount\n        );\n        uint256[] memory _projectRepaymentStartDate = new uint256[](\n            communities[_communityID].projectCount\n        );\n        uint256[] memory _projectRepaymentEndDate = new uint256[](\n            communities[_communityID].projectCount\n        );\n        uint256[] memory _investmentNeeded = new uint256[](\n            communities[_communityID].projectCount\n        );\n\n        for (uint256 i = 0; i < communities[_communityID].memberCount; i++) {\n            _membersArray[i] = communities[_communityID].members[i];\n        }\n        for (uint256 i = 0; i < communities[_communityID].projectCount; i++) {\n            _projectArray[i] = communities[_communityID].projects[i];\n            _projectApr[i] = communities[_communityID]\n                .projectDetails[_projectArray[i]]\n                .apr;\n            _projectRepaymentStartDate[i] = communities[_communityID]\n                .projectDetails[_projectArray[i]]\n                .repaymentStartDate;\n            _projectRepaymentEndDate[i] = communities[_communityID]\n                .projectDetails[_projectArray[i]]\n                .repaymentEndDate;\n            _investmentNeeded[i] = communities[_communityID]\n                .projectDetails[_projectArray[i]]\n                .investmentNeeded;\n        }\n        return (\n            _membersArray,\n            _projectArray,\n            _projectApr,\n            _projectRepaymentStartDate,\n            _projectRepaymentEndDate,\n            _investmentNeeded\n        );\n    }\n\n    /// INTERNAL FUNCTIONS ///\n\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        address _user,\n        IToken20 _wrappedToken\n    ) internal override {\n        (uint256 _amountToReturn, uint256 _invested) = returnToInvestor(\n            _communityID,\n            _project,\n            _user\n        );\n        require(_invested > 0, \"Community::Claimed\");\n        if (_amountToReturn > _invested) {\n            communities[_communityID]\n                .projectDetails[_project]\n                .investmentDetails[_user]\n                .investedAmount = _amountToReturn;\n            communities[_communityID]\n                .projectDetails[_project]\n                .investmentDetails[_user]\n                .investmentTimestamp = block.timestamp;\n            uint256 _interestEarned = _amountToReturn - _invested;\n            _wrappedToken.mint(_user, _interestEarned);\n            eventsInstance.claimedInterest(\n                _communityID,\n                _project,\n                _user,\n                _interestEarned,\n                _amountToReturn\n            );\n        }\n    }\n}\n",
            "keccak256": "0xfa7b1f465e9e1f70ffacab9809ed444f40699d61c0d598a56ef7ff8f13b0f5b8",
            "license": "UNLICENSED"
        },
        "contracts/interfaces/ICommunity.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport \"./IHomeFi.sol\";\nimport \"./IToken20.sol\";\nimport \"./IProject.sol\";\n\n/**\n * Interface defining module for coordinating investment groups on HomeFi protocol\n */\nabstract contract ICommunity is\n    ERC2771ContextUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /// MODIFIERS ///\n\n    modifier checkMember(uint256 _communityID, address _user) {\n        // determine whether an address is enrolled as a member in a community\n        require(\n            communities[_communityID].isMember[_user],\n            \"Community::!Member\"\n        );\n        _;\n    }\n\n    modifier nonZero(address _address) {\n        // ensure an address is not the zero address (0x00)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    /// STRUCTS ///\n\n    struct InvestmentDetails {\n        // object storing data for individual investment event\n        address investor; // we don't need that as we already know it from the mapping\n        uint256 investedAmount;\n        uint256 investmentTimestamp;\n        bool status; //if true, block has been repaid by builder already\n    }\n\n    struct ProjectDetails {\n        // object storing data about project for investors in community\n        bool exists;\n        uint256 apr; //interest rate for the project (in per thousand)\n        uint256 repaymentStartDate; //unix timestamp when repayment starts\n        uint256 repaymentEndDate; //unix timestamp when repayment is late\n        uint256 investmentNeeded; //total investment requirement in community currency to launch\n        uint256 investmentCount; // from index 1\n        mapping(address => InvestmentDetails) investmentDetails; // investor address => InvestmentDetails\n    }\n\n    struct CommunityStruct {\n        // object storing all data relevant to an investment community\n        address owner;\n        IToken20 currency;\n        uint256 memberCount; // from index 0\n        uint256 projectCount; // from index 0\n        mapping(uint256 => address) members;\n        mapping(address => bool) isMember;\n        mapping(uint256 => address) projects;\n        mapping(address => ProjectDetails) projectDetails;\n    }\n\n    address internal wrappedNativeCurrency;\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    IEvents internal eventsInstance;\n    IHomeFi public homeFiInstance;\n    bool public adminLock;\n\n    uint256 public communityCount; //starts from 1\n    mapping(uint256 => CommunityStruct) public communities;\n\n    /**\n     * @notice checks trustedForwarder on HomeFi contract\n     * @param _forwarder address of contract forwarding meta tx\n     */\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return homeFiInstance.isTrustedForwarder(_forwarder);\n    }\n\n    /// CONSTRUCTOR ///\n\n    /**\n     * Initialize a new communities contract\n     * @notice THIS IS THE CONSTRUCTOR thanks upgradable proxies\n     * @dev modifier initializer\n     *\n     * @param _homeFi address - instance of main HomeFi contract. Can be accessed with raw address\n     * @param _eventsContract address - instance of events contract. Can be accessed with raw address\n     */\n    function initialize(address _homeFi, address _eventsContract)\n        external\n        virtual;\n\n    /// MUTABLE FUNCTIONS ///\n\n    function setAdminLock(bool _locked) external virtual;\n\n    /**\n     * Create a new investment community on HomeFi\n     *\n     * @param _hash bytes - the identifying hash of the community\n     * @param _currency address - the currency accepted for creating new HomeFi debt tokens\n     */\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        virtual;\n\n    /**\n     * Update the internal identifying hash of a community\n     * @notice IDK why exactly this exists yet\n     *\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _hash bytes - the new hash to update the community hash to\n     */\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        virtual;\n\n    /**\n     * Add a new member to an investment community\n     * @notice Comprises of both request to join and join.\n     *\n     * @param _data bytes - data encoded:\n     * - _communityID community count\n     * - _memberAddr member address to add\n     * @param _signature bytes - _data signed by the community owner\n     */\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual;\n\n    /**\n     * Add a new project to an investment community\n     * @dev modifier onlyBuilder\n     * @dev modifier checkMember\n     *\n     * @param _communityID uint256 - the the uuid (serial) of the community being published to\n     * @param _project address - the project contract being added to the community for investment\n     * @param _projectDetails uint256[] - integer metadata for project\n     *  - [0] = APR; [1]: Min repayment timestamp; [2]: Max repayment timestamp; [3]: investment needed\n     *  - NOTE: APR is in per thousand. Ex: 5% interest => APR = 50\n     */\n    function publishProject(\n        uint256 _communityID,\n        address _project,\n        uint256[] calldata _projectDetails\n    ) external virtual;\n\n    /**\n     * As a community member, invest in a project and create new HomeFi debt tokens\n     * @notice this is where funds flow into contracts for investors\n     * @dev modifier checkMember\n     * @dev modifier nonReentrant\n     * @dev users MUST call approve on respective token contracts for the community contract first\n     * @dev If the project's currency is native, then user can also pay in the native currency\n     * @dev by passing msg.value, it will be converted in to wrapped tokens internally\n     *\n     * @param _communityID uint256 - the the uuid (serial) of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _cost uint256 - the number of tokens of the community currency to invest\n     */\n    function investInProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _cost\n    ) external payable virtual;\n\n    /**\n     * As a builder, repay an investor for their investment with interest\n     * @notice this is where funds flow out of contracts for investors\n     * @dev modifier onlyBuilder\n     * @dev modifier nonReentrant\n     * @dev modifier nonZero(_investor)\n     * @dev users MUST call approve on respective token contracts for the community contract first\n     * @dev If the project's currency is native, then user can also pay in the native currency\n     * @dev by passing msg.value, it will be converted in to wrapped tokens internally\n     *\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _investor address - the address of the investor to repay + interest\n     * @param _repayAmount uint256 - the amount of funds repaid to the investor, in the project currency\n     */\n    function repayInvestor(\n        uint256 _communityID,\n        address _project,\n        address _investor,\n        uint256 _repayAmount\n    ) external payable virtual;\n\n    /**\n     * As an investor, if the repayment was done off platform then can mark their debt paid\n     * @dev modifier nonReentrant\n     *\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _repayAmount uint256 - the amount of funds repaid to the investor, in the project currency\n     * @param _details bytes - some details on why debt is reduced (off chain documents or images)\n     */\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes calldata _details\n    ) external virtual;\n\n    /**\n     * Transfer ownership of investments from one user to another\n     * @dev modifier nonReentrant\n     * @dev modifier nonZero(_to)\n     * @notice in practice transfer debt erc20 tokens + update references in custom nft logic\n     *\n     * @param _communityID uint256 - the the uuid (serial) of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _to address - the address receiving ownership of the specified investments\n     * @param _amount amount of debt token he want to transfer\n     * @return bool - will always return true if does not revert during execution\n     */\n    function transferFraction(\n        uint256 _communityID,\n        address _project,\n        address _to,\n        uint256 _amount\n    ) external virtual returns (bool);\n\n    /// VIEWABLE FUNCTIONS ///\n\n    /**\n     * Calculate the payout for a given investor on their investments as queried\n     * @dev modifier onlyBuilder\n     * @dev modifier nonZero(_investor)\n     *\n     * @param _communityID uint256 - the the uuid (serial) of the community where the investment took place\n     * @param _project address - the address of the deployed project contract\n     * @param _investor address - the address of the investor to repay + interest\n     * @return _return uint256 - the amount invested by _address + interest paid (the amount of tokens reclaimed)\n     * @return _invested uint256 - the amount _address invested initially\n     */\n    function returnToInvestor(\n        uint256 _communityID,\n        address _project,\n        address _investor\n    ) public view virtual returns (uint256 _return, uint256 _invested);\n\n    /**\n     * Return all info about a specific community\n     *\n     * @param _communityID uint256 - the uuid (serial) of the community to query\n     * @return _members address[] - array of all member accounts\n     * @return _projects address[] - array of all projects the community can invest in\n     * @return _apr uint256[] - array of interest rates with index relating to _projects\n     * @return _min uint256[] - array of starting date of debt repayments with index relating to _projects\n     * @return _max uint256[] - array of final date of debt repayment with index relating to _projects (double APR after)\n     * @return _investment uint256[] - array of amounts needed by projects before investment completes with index relating to _projects\n     */\n    function communityDetails(uint256 _communityID)\n        external\n        view\n        virtual\n        returns (\n            address[] memory _members,\n            address[] memory _projects,\n            uint256[] memory _apr,\n            uint256[] memory _min,\n            uint256[] memory _max,\n            uint256[] memory _investment\n        );\n\n    /// INTERNAL FUNCTIONS ///\n\n    /**\n     * @dev interest of investor\n     * @param _communityID uint256 - uuid of community the project is held in\n     * @param _project address - address of project where debt/ loan is held\n     * @param _user address - address of investor claiming interest\n     * @param _wrappedToken address - debt token investor is claiming\n     */\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        address _user,\n        IToken20 _wrappedToken\n    ) internal virtual;\n}\n",
            "keccak256": "0x67371eb405a3e056cd1f383fe7a7e3c7ccc0a890153a06ec83b5f9e3b777533f",
            "license": "UNLICENSED"
        },
        "contracts/interfaces/IDisputes.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"./IHomeFi.sol\";\nimport \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport \"../libraries/SignatureDecoder.sol\";\n\ninterface IProjectContract {\n    function addPhasesGC(bytes calldata, bytes calldata) external;\n\n    function changeCostGC(bytes calldata, bytes calldata) external;\n\n    function releaseFeeContractor(uint256 _phaseID) external;\n\n    function addTasks(bytes calldata, bytes calldata) external;\n\n    function changeOrder(bytes calldata, bytes calldata) external;\n\n    function setComplete(bytes calldata, bytes calldata) external;\n\n    function tasks(uint256)\n        external\n        view\n        returns (\n            uint256,\n            address,\n            uint8\n        );\n\n    function builder() external view returns (address);\n\n    function contractor() external view returns (address);\n}\n\n/**\n * Module for raising disputes for arbitration within HomeFi projects\n */\nabstract contract IDisputes is\n    ERC2771ContextUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /// INTERFACES ///\n\n    IHomeFi public homeFi;\n    IEvents public eventsInstance;\n\n    /// MODIFIERS ///\n\n    modifier nonZero(address _address) {\n        // ensure an address is not the zero address (0x00)\n        require(_address != address(0), \"Dispute::0 address\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        // ensure that only HomeFi admins can arbitrate disputes\n        require(homeFi.admin() == _msgSender(), \"Dispute::!Admin\");\n        _;\n    }\n\n    modifier onlyProject() {\n        // ensure the call originates from a valid project contract\n        require(homeFi.projectExist(_msgSender()), \"Dispute::!Project\");\n        _;\n    }\n\n    /**\n     * Affirm that a given dispute is currently resolvable\n     * @param _disputeID uint256 - the serial/id of the dispute\n     */\n    modifier resolvable(uint256 _disputeID) {\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n        _;\n    }\n\n    /**\n     * @notice checks trustedForwarder on HomeFi contract\n     * @param _forwarder address of contract forwarding meta tx\n     */\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /// ENUMERATIONS ///\n\n    enum Status {\n        None,\n        Active,\n        Accepted,\n        Rejected\n    }\n\n    //determines how dispute action params are parsed and executed\n    enum ActionType {\n        None,\n        PhaseAdd,\n        PhaseChange,\n        PhasePay,\n        TaskAdd,\n        TaskChange,\n        TaskPay\n    }\n\n    /// STRUCTS ///\n\n    struct Dispute {\n        // Object storing metadata around disputes\n        Status status; //the ruling on the dispute (see Status enum for all possible cases)\n        address project; //project the dispute occurred in\n        uint256 taskID; // task the dispute occurred in\n        address raisedBy; // user who raised the dispute\n        ActionType actionType;\n        bytes actionData;\n    }\n\n    /// DATA STORAGE ///\n\n    mapping(uint256 => Dispute) public disputes;\n    uint256 public disputeCount; //starts from 0\n\n    /// CONSTRUCTOR ///\n\n    /**\n     * Initialize a new communities contract\n     * @notice THIS IS THE CONSTRUCTOR thanks upgradable proxies\n     * @dev modifier initializer\n     *\n     * @param _homeFi address - address of main homeFi contract\n     * @param _eventsContract address - address of events contract\n     */\n    function initialize(address _homeFi, address _eventsContract)\n        external\n        virtual;\n\n    /// MUTABLE FUNCTIONS ///\n\n    /**\n     * Asserts whether a given address is a member of a project,\n     * Reverts if address not a member\n     *\n     * @param _project address - the project being queried for membership\n     * @param _task uint256 - the index/serial of the task\n     *  - if not querying for subcontractor, set as 0\n     * @param _address address - the address being checked for membership\n     */\n    function assertMember(\n        address _project,\n        uint256 _task,\n        address _address\n    ) public virtual;\n\n    /**\n     * Raise a new dispute\n     * @dev modifier\n     * @dev modifier onlyMember (must be decoded first)\n     *\n     * @param _data bytes\n     *   - 0: project address, 1: task id (0 if none), 2: action disputeType, 3: action data, 5: ipfs cid of pdf\n     *   - const types = [\"address\", \"uint256\", \"uint8\", \"bytes\", \"bytes\"]\n     * @param _signature bytes - hash of _data signed by the address raising dispute\n     */\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        returns (uint256);\n\n    /**\n     * Attach cid of arbitrary documents used to arbitrate disputes\n     *\n     * @param _disputeID uint256 - the uuid/serial of the dispute within this contract\n     * @param _attachment bytes - the URI of the document being added\n     */\n    function attachDocument(uint256 _disputeID, bytes calldata _attachment)\n        external\n        virtual;\n\n    /**\n     * Arbitrate a dispute & execute accompanying enforcement logic to achieve desired project state\n     * @dev modifier onlyAdmin\n     *\n     * @param _disputeID uint256 - the uuid (serial) of the dispute in this contract\n     * @param _judgement bytes - the URI hash of the document to be used to close the dispute\n     * @param _ratify bool - true if status should be set to accepted, and false if rejected\n     */\n    function resolveDispute(\n        uint256 _disputeID,\n        bytes calldata _judgement,\n        bool _ratify\n    ) external virtual;\n\n    /// INTERNAL FUNCTIONS ///\n\n    /**\n     * Given an id, attempt to execute the action to enforce the arbitration\n     * @dev modifier actionUsed\n     * @dev needs reentrant check\n     * @notice logic for decoding and enforcing outcome of arbitration judgement\n     *\n     * @param _disputeID uint256 - the dispute to attempt to\n     */\n    function resolveHandler(uint256 _disputeID) internal virtual;\n\n    /**\n     * Arbitration enforcement of changing costs of phases\n     * @notice should only ever be used by resolveHandler\n     *\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the phase add transaction data stored when dispute was raised\n     * - uint256[] _phaseCosts array where each element represent phase cost, length of this array is number of phase to be added\n     * - uint256 _phaseCount current phase count, for signature security\n     * - address _projectAddress this project address, for signature security\n     */\n    function executePhaseAdd(address _project, bytes memory _actionData)\n        internal\n        virtual;\n\n    /**\n     * Arbitration enforcement of changing costs of phases\n     * @notice should only ever be used by resolveHandler\n     *\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the phase change transaction data stored when dispute was raised\n     *   - 0: array indexes of tasks under dispute, 1: costs to set corresponding to first array, 2: project address\n     *   - const types = [\"uint256[]\", \"uint256[]\", \"address\"]\n     */\n    function executePhaseChange(address _project, bytes memory _actionData)\n        internal\n        virtual;\n\n    /**\n     * Arbitration enforcement of paying General Contractor phase fees\n     * @notice should only ever be used by resolveHandler\n     *\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the phase payout transaction data stored when dispute was raised\n     *   - 0: phase under payment dispute, 2: project address\n     *   - const types = [\"uint256\", \"address\"]\n     */\n    function executePhasePay(address _project, bytes memory _actionData)\n        internal\n        virtual;\n\n    /**\n     * Arbitration enforcement of task change orders\n     * @notice should only ever be used by resolveHandler\n     *\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task add transaction data stored when dispute was raised\n     * - uint256 _phaseID phase number in which tasks are added\n     * - bytes[] _hash an array whose length is equal to number of task that you want to add,\n     *   and each element is bytes converted IPFS hash of task\n     * - uint256[] _cost an array of cost for each task index\n     * - address[] _sc an array subcontractor address for each task index\n     * - uint256 _taskSerial current task count/serial before adding these tasks. Can be fetched by taskSerial.\n     * - address _projectAddress the address of this contract. For signature security.\n     */\n    function executeTaskAdd(address _project, bytes memory _actionData)\n        internal\n        virtual;\n\n    /**\n     * Arbitration enforcement of task change orders\n     * @notice should only ever be used by resolveHandler\n     *\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task change order transaction data stored when dispute was raised\n     * - 0: index of phase; 1: index of task; 2: task subcontractor; 3: task cost; 4: project address\n     * - [\"uint256\", \"uint256\", \"address\", \"uint256\", \"address\"]\n     */\n    function executeTaskChange(address _project, bytes memory _actionData)\n        internal\n        virtual;\n\n    /**\n     * Arbitration enforcement of task payout\n     * @notice should only ever be used by resolveHandler\n     *\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task payout transaction data stored when dispute was raised\n     * - 0: index of task; 2: project address\n     * - [\"uint256\", \"address\"]\n     */\n    function executeTaskPay(address _project, bytes memory _actionData)\n        internal\n        virtual;\n}\n",
            "keccak256": "0x7cae3a042ead6bb891d3d0d659e91f507b04408d338cf0e6faad436b6f059542",
            "license": "UNLICENSED"
        },
        "contracts/interfaces/IEvents.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ninterface IHomeFiContract {\n    function projectExist(address _project) external returns (bool);\n\n    function communityContract() external returns (address);\n\n    function disputeContract() external returns (address);\n}\n\nabstract contract IEvents is Initializable {\n    /// EVENTS ///\n\n    // HomeFi.sol Events //\n    event AddressSet();\n    event ProjectAdded(\n        uint256 _projectID,\n        address indexed _project,\n        address indexed _builder,\n        address indexed _currency,\n        bytes _hash\n    );\n    event NftCreated(uint256 _id, address _owner);\n    event AdminReplaced(address _newAdmin);\n    event TreasuryReplaced(address _newTreasury);\n    event NetworkFeeReplaced(uint256 _newBuilderFee, uint256 _newInvestorFee);\n\n    // Project.sol Events //\n    event HashUpdated(address indexed _project, bytes _hash);\n    event ContractorInvited(\n        address indexed _project,\n        address indexed _newContractor,\n        uint256[] _phaseCosts\n    );\n    event PhasesAdded(address indexed _project, uint256[] _phaseCosts);\n    event PhasesUpdated(\n        address indexed _project,\n        uint256[] _phaseList,\n        uint256[] _phaseCosts\n    );\n    event InvestedInProject(address indexed _project, uint256 _cost);\n    event IncompleteFund(address indexed _project);\n    event TasksAdded(\n        address indexed _project,\n        uint256 _phaseID,\n        uint256[] _taskCosts,\n        bytes[] _taskHashes\n    );\n    event TaskHashUpdated(\n        address indexed _project,\n        uint256 _taskID,\n        bytes _taskHash\n    );\n    event MultipleSCInvited(\n        address indexed _project,\n        uint256[] _taskList,\n        address[] _scList\n    );\n    event SingleSCInvited(\n        address indexed _project,\n        uint256 _taskID,\n        address _sc\n    );\n    event SCConfirmed(address indexed _project, uint256[] _taskList);\n    event TaskFunded(address indexed _project, uint256[] _taskIDs);\n    event TaskComplete(address indexed _project, uint256 _taskID);\n    event ContractorFeeReleased(address indexed _project, uint256 _phaseID);\n    event ChangeOrderFee(\n        address indexed _project,\n        uint256 _taskID,\n        uint256 _newCost\n    );\n    event ChangeOrderSC(address indexed _project, uint256 _taskID, address _sc);\n    event AutoWithdrawn(address indexed _project, uint256 _amount);\n\n    // Disputes.sol Events //\n    event DisputeRaised(uint256 indexed _disputeID, bytes _reason);\n    event DisputeResolved(\n        uint256 indexed _disputeID,\n        bool _ratified,\n        bytes _judgement\n    );\n    event DisputeAttachmentAdded(\n        uint256 indexed _disputeID,\n        address _user,\n        bytes _attachment\n    );\n\n    // Community.sol Events //\n    event AdminLock(bool _locked);\n    event CommunityAdded(\n        uint256 _communityID,\n        address indexed _owner,\n        address indexed _currency,\n        bytes _hash\n    );\n    event UpdateCommunityHash(uint256 _communityID, bytes _newHash);\n    event MemberAdded(uint256 indexed _communityID, address indexed _member);\n    event ProjectPublished(\n        uint256 indexed _communityID,\n        address indexed _project,\n        uint256 _apr\n    );\n    event InvestorInvested(\n        uint256 indexed _communityID,\n        address indexed _project,\n        address indexed _investor,\n        uint256 _cost\n    );\n    event RepayInvestor(\n        uint256 indexed _communityID,\n        address indexed _project,\n        address indexed _investor,\n        uint256 _tAmount\n    );\n    event DebtReduced(\n        uint256 indexed _communityID,\n        address indexed _project,\n        address indexed _investor,\n        uint256 _tAmount,\n        bytes _details\n    );\n    event DebtTransferred(\n        uint256 indexed _communityID,\n        address indexed _project,\n        address indexed _investor,\n        address _to,\n        uint256 _totalAmount\n    );\n    event ClaimedInterest(\n        uint256 indexed _communityID,\n        address indexed _project,\n        address indexed _investor,\n        uint256 _interestEarned,\n        uint256 _totalAmount\n    );\n\n    /// MODIFIERS ///\n    modifier validProject() {\n        // ensure that the caller is an instance of Project.sol\n        require(homeFi.projectExist(msg.sender), \"Events::!ProjectContract\");\n        _;\n    }\n\n    modifier onlyDisputeContract() {\n        // ensure that the caller is deployed instance of Dispute.sol\n        require(\n            homeFi.disputeContract() == msg.sender,\n            \"Events::!DisputeContract\"\n        );\n        _;\n    }\n\n    modifier onlyHomeFi() {\n        // ensure that the caller is the deployed instance of HomeFi.sol\n        require(address(homeFi) == msg.sender, \"Events::!HomeFiContract\");\n        _;\n    }\n\n    modifier onlyCommunityContract() {\n        // ensure that the caller is the deployed instance of Community.sol\n        require(\n            homeFi.communityContract() == msg.sender,\n            \"Events::!CommunityContract\"\n        );\n        _;\n    }\n\n    IHomeFiContract public homeFi;\n\n    /// CONSTRUCTOR ///\n\n    /**\n     * Initialize a new events contract\n     * @notice THIS IS THE CONSTRUCTOR thanks upgradable proxies\n     * @dev modifier initializer\n     *\n     * @param _homeFi IHomeFi - instance of main Rigor contract. Can be accessed with raw address\n     */\n    function initialize(address _homeFi) external virtual;\n\n    /// FUNCTIONS ///\n\n    /**\n     * Call to event when address is set\n     * @dev modifier onlyHomeFi\n     */\n    function addressSet() external virtual;\n\n    /**\n     * Call to emit when a project is created (new NFT is minted)\n     * @dev modifier onlyHomeFi\n     *\n     * @param _projectID uint256 - the ERC721 enumerable index/ uuid of the project\n     * @param _project address - the address of the newly deployed project contract\n     * @param _builder address - the address of the user permissioned as the project's builder\n     */\n    function projectAdded(\n        uint256 _projectID,\n        address _project,\n        address _builder,\n        address _currency,\n        bytes calldata _hash\n    ) external virtual;\n\n    /**\n     * Call to emit when a new project & accompanying ERC721 token have been created\n     * @dev modifier onlyHomeFi\n     *\n     * @param _id uint256 - the ERC721 enumerable serial/ project id\n     * @param _owner address - address permissioned as project's builder/ nft owner\n     */\n    function nftCreated(uint256 _id, address _owner) external virtual;\n\n    /**\n     * Call to emit when HomeFi admin is replaced\n     * @dev modifier onlyHomeFi\n     *\n     * @param _newAdmin address - address of the new admin\n     */\n    function adminReplaced(address _newAdmin) external virtual;\n\n    /**\n     * Call to emit when HomeFi treasury is replaced\n     * @dev modifier onlyHomeFi\n     *\n     * @param _newTreasury address - address of the new treasury\n     */\n    function treasuryReplaced(address _newTreasury) external virtual;\n\n    /**\n     * Call to emit when HomeFi treasury network fee is updated\n     * @dev modifier onlyHomeFi\n     *\n     * @param _newBuilderFee uint256 - percentage of fee builder have to pay to rigor system\n     * @param _newInvestorFee uint256 - percentage of fee investor have to pay to rigor system\n     */\n    function networkFeeReplaced(uint256 _newBuilderFee, uint256 _newInvestorFee)\n        external\n        virtual;\n\n    /**\n     * Call to emit when the hash of a project is updated\n     *\n     * @param _updatedHash bytes - hash of project metadata used to identify the project\n     */\n    function hashUpdated(bytes calldata _updatedHash) external virtual;\n\n    /**\n     * Call to emit when a new General Contractor is invited and accepted to a HomeFi project\n     * @dev modifier validProject\n     *\n     * @param _contractor address - the address invited to the project as the general contractor\n     * @param _phaseCosts uint256[] - array (length = number of phases) of contractor fees to be paid per phase\n     */\n    function contractorInvited(\n        address _contractor,\n        uint256[] calldata _phaseCosts\n    ) external virtual;\n\n    /**\n     * Call to emit when a project has phases added\n     * @dev modifier validProject\n     *\n     * @param _phaseCosts uint256[] - array of added phases' costs\n     */\n    function phasesAdded(uint256[] calldata _phaseCosts) external virtual;\n\n    /**\n     * Call to emit when a project's phases are updated\n     * @dev modifier validProject\n     *\n     * @param _phaseList uint256[] - array of phase indices to mutate cost for\n     * @param _phaseCosts uint256[] - array of phaseCosts to change with array index corresponding to _phaseList[index] task\n     */\n    function phasesUpdated(\n        uint256[] calldata _phaseList,\n        uint256[] calldata _phaseCosts\n    ) external virtual;\n\n    /**\n     * Call to emit when a task's identifying hash is changed\n     * @dev modifier validProject\n     *\n     * @param _taskID uint256 - the uuid of the updated task\n     * @param _taskHash bytes[] - bytes conversion of IPFS hash\n     */\n    function taskHashUpdated(uint256 _taskID, bytes calldata _taskHash)\n        external\n        virtual;\n\n    /**\n     * Call to emit when a new task is created in a project\n     * @dev modifier validProject\n     *\n     * @param _phaseID uint256 - the phase to which the task was added\n     * @param _taskCosts uint256[] - array of added tasks' costs\n     * @param _taskHashes bytes[] - bytes array of added tasks' hash part 1\n     */\n    function tasksAdded(\n        uint256 _phaseID,\n        uint256[] calldata _taskCosts,\n        bytes[] calldata _taskHashes\n    ) external virtual;\n\n    /**\n     * Call to emit when an investor has loaned funds to a project\n     * @dev modifier validProject\n     *\n     * @param _cost uint256 - the amount of currency invested in the project (depends on project currency)\n     */\n    function investedInProject(uint256 _cost) external virtual;\n\n    /**\n     * Call to emit when an project has incomplete funding\n     * @dev modifier validProject\n     */\n    function incompleteFund() external virtual;\n\n    /**\n     * Call to emit when subcontractors are invited to tasks\n     * @dev modifier validProject\n     *\n     * @param _taskList uint256[] - the list of uuids of the tasks the subcontractors are being invited to\n     * @param _scList address[] - the addresses of the users being invited as subcontractor to the tasks\n     */\n    function multipleSCInvited(\n        uint256[] calldata _taskList,\n        address[] calldata _scList\n    ) external virtual;\n\n    /**\n     * Call to emit when a subcontractor is invited to a task\n     * @dev modifier validProject\n     *\n     * @param _taskID uint256 - the uuid of the task the subcontractor is being invited to\n     * @param _sc address - the address of the user being invited as subcontractor to the task\n     */\n    function singleSCInvited(uint256 _taskID, address _sc) external virtual;\n\n    /**\n     * Call to emit when a subcontractor is confirmed for a task\n     * @dev modifier validProject\n     *\n     * @param _taskList uint256[] - the uuid's of the taskList joined by the subcontractor\n     */\n    function scConfirmed(uint256[] calldata _taskList) external virtual;\n\n    /**\n     * Call to emit when a task is funded\n     * @dev modifier validProject\n     *\n     * @param _taskIDs uint256[] - array of uuid of the funded task\n     */\n    function taskFunded(uint256[] calldata _taskIDs) external virtual;\n\n    /**\n     * Call to emit when a task has been completed\n     * @dev modifier validProject\n     *\n     * @param _taskID uint256 - the uuid of the completed task\n     */\n    function taskComplete(uint256 _taskID) external virtual;\n\n    /**\n     * Call to emit when a phase has been completed/ the contractor fee for the phase has been released from escrow\n     * @dev modifier validProject\n     *\n     * @param _phaseID uint256 - the index of the completed phase\n     */\n    function contractorFeeReleased(uint256 _phaseID) external virtual;\n\n    /**\n     * Call to emit when a task has a change order changing the cost of a task\n     * @dev modifier validProject\n     *\n     * @param _taskID uint256 - the uuid of the task where the change order occurred\n     * @param _newCost uint256 - the new cost of the task (in the project currency)\n     */\n    function changeOrderFee(uint256 _taskID, uint256 _newCost) external virtual;\n\n    /**\n     * Call to emit when a task has a change order that swaps the subcontractor on the task\n     * @dev modifier validProject\n     *\n     * @param _taskID uint256 - the uuid of the task where the change order occurred\n     * @param _sc uint256 - the subcontractor being added to the task in the change order\n     */\n    function changeOrderSC(uint256 _taskID, address _sc) external virtual;\n\n    /**\n     * Call to event when transfer excess funds back to builder wallet\n     * @dev modifier validProject\n     *\n     * @param _amount uint256 - amount of excess fund\n     */\n    function autoWithdrawn(uint256 _amount) external virtual;\n\n    /**\n     * Call to emit when an investor's loan is repaid with interest\n     * @dev modifier onlyCommunityContract\n     *\n     * @param _communityID uint256 - the uuid of the community that the project loan occurred in\n     * @param _project address - the address of the deployed contract address where the loan was escrowed\n     * @param _investor address - the address that supplied the loan/ is receiving repayment\n     * @param _tAmount uint256 - the amount repaid to the investor (principal + interest) in the project currency\n     */\n    function repayInvestor(\n        uint256 _communityID,\n        address _project,\n        address _investor,\n        uint256 _tAmount\n    ) external virtual;\n\n    /**\n     * Call to emit when an investor's loan is reduced with repayment done off platform\n     * @dev modifier onlyCommunityContract\n     *\n     * @param _communityID uint256 - the uuid of the community that the project loan occurred in\n     * @param _project address - the address of the deployed contract address where the loan was escrowed\n     * @param _investor address - the address that supplied the loan/ is receiving repayment\n     * @param _tAmount uint256 - the amount repaid to the investor (principal + interest) in the project currency\n     * @param _details bytes - some _details on why debt is reduced (off chain documents or images)\n     */\n    function debtReduced(\n        uint256 _communityID,\n        address _project,\n        address _investor,\n        uint256 _tAmount,\n        bytes calldata _details\n    ) external virtual;\n\n    /**\n     * Call to emit when a new dispute is raised\n     * @dev modifier onlyDisputeContract\n     *\n     * @param _disputeID uint256 - the uuid/ serial of the dispute within the dispute contract\n     * @param _reason bytes - ipfs cid of pdf\n     */\n    function disputeRaised(uint256 _disputeID, bytes calldata _reason)\n        external\n        virtual;\n\n    /**\n     * Call to emit when a dispute has been arbitrated and funds have been directed to the correct address\n     * @dev modifier onlyDisputeContract\n     *\n     * @param _disputeID uint256 - the uuid/serial of the dispute within the dispute contract\n     * @param _ratified bool - true if disputed action was enforced by arbitration, and false otherwise\n     * @param _judgement bytes - the URI hash of the document to be used to close the dispute\n     */\n    function disputeResolved(\n        uint256 _disputeID,\n        bool _ratified,\n        bytes calldata _judgement\n    ) external virtual;\n\n    /**\n     * Call to emit when a document is attached to a dispute\n     * @dev modifier onlyDisputeContract\n     *\n     * @param _disputeID uint256 - the uuid/ serial of the dispute\n     * @param _user address - the address of the user uploading the document\n     * @param _attachment bytes - the IPFS cid of the dispute attachment document\n     */\n    function disputeAttachmentAdded(\n        uint256 _disputeID,\n        address _user,\n        bytes calldata _attachment\n    ) external virtual;\n\n    /**\n     * Call to emit when community creation is locked or unlocked\n     * @dev modifier onlyCommunityContract\n     *\n     * @param _locked bool - the status of adminLock\n     */\n    function adminLock(bool _locked) external virtual;\n\n    /**\n     * Call to emit when a new investment community is created\n     * @dev modifier onlyCommunityContract\n     *\n     * @param _communityID uint256 - the uuid/ serial of the created investment community\n     * @param _owner address - the address of the user who manages the investment community\n     * @param _currency address - the address of the currency used as collateral in projects within the community\n     * @param _hash bytes - the hash of community metadata used to identify the community\n     */\n    function communityAdded(\n        uint256 _communityID,\n        address _owner,\n        address _currency,\n        bytes calldata _hash\n    ) external virtual;\n\n    /**\n     * Call to emit when a community's identifying hash is updated\n     * @dev modifier onlyCommunityContract\n     *\n     * @param _communityID uint256 - the uuid/ serial of the investment community whose hash is being updated\n     * @param _newHash bytes - the new hash of community metadata used to identify the community being added\n     */\n    function updateCommunityHash(uint256 _communityID, bytes calldata _newHash)\n        external\n        virtual;\n\n    /**\n     * Call to emit when a member has been added to an investment community as a new investor\n     * @dev modifier onlyCommunityContract\n     *\n     * @param _communityID uint256 - the uuid/ serial of the investment community being joined\n     * @param _member address - the address of the user joining the community as an investor\n     */\n    function memberAdded(uint256 _communityID, address _member)\n        external\n        virtual;\n\n    /**\n     * Call to emit when a project is added to an investment community for fund raising\n     * @dev modifier onlyCommunityContract\n     *\n     * @param _communityID uint256 - the uuid/ serial of the community being published to\n     * @param _project address - the address of the deployed project contract where loans are escrowed\n     * @param _apr uint256 - the annual percentage return (interest rate) on loans made to the project\n     */\n    function projectPublished(\n        uint256 _communityID,\n        address _project,\n        uint256 _apr\n    ) external virtual;\n\n    /**\n     * Call to emit when an investor loans funds to a project\n     * @dev modifier onlyCommunityContract\n     *\n     * @param _communityID uint256 - the uuid/ serial of the community the project is published in\n     * @param _project address - the address of the deployed project contract the investor loaned funds to\n     * @param _investor address - the address of the investing user\n     * @param _cost uint256 - the amount of funds invested by _investor, in the project currency\n     */\n    function investorInvested(\n        uint256 _communityID,\n        address _project,\n        address _investor,\n        uint256 _cost\n    ) external virtual;\n\n    /**\n     * Call to emit when fractional ownership of a project's debt is transferred\n     * @dev modifier onlyCommunityContract\n     *\n     * @param _communityID uint256 - the uuid/ serial of the community the project is published in\n     * @param _project address - the address of the deployed project contract tracked by the NFT\n     * @param _investor address - the current owner who is sending the fractional ownership of the NFT\n     * @param _to address - the new owner who is the recipient of fractional ownership of the NFT\n     * @param _totalAmount uint256 - the amount of debt tokens transferred (in the project's wrapped currency)\n     */\n    function debtTransferred(\n        uint256 _communityID,\n        address _project,\n        address _investor,\n        address _to,\n        uint256 _totalAmount\n    ) external virtual;\n\n    /**\n     * Call to emit when an investor claims their repayment with interest\n     * @dev modifier onlyCommunityContract\n     *\n     * @param _communityID uint256 - the uuid/ serial of the community the project is published in\n     * @param _project address - the address of the deployed project contract the investor loaned to\n     * @param _investor address - the address of the investor claiming interest\n     * @param _interestEarned uint256 - the amount of collateral tokens earned in interest (in project's currency)\n     * @param _totalAmount uint256 - collateral tokens: principal + interest returned to investor\n     */\n    function claimedInterest(\n        uint256 _communityID,\n        address _project,\n        address _investor,\n        uint256 _interestEarned,\n        uint256 _totalAmount\n    ) external virtual;\n}\n",
            "keccak256": "0xc4b8d40d94e4dfdf01cf79b03481eaf115a9f457490930e74bbae173a05d37da",
            "license": "UNLICENSED"
        },
        "contracts/interfaces/IHomeFi.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport \"./IEvents.sol\";\nimport \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/metatx/MinimalForwarder.sol\";\n\ninterface IProjectFactory {\n    function createProject(address _currency, address _sender)\n        external\n        returns (address _clone);\n}\n\n/**\n * @title HomeFi v0.1.0 ERC721 Contract Interface\n * @notice Interface for main on-chain client for HomeFi protocol\n * Interface for administrative controls and project deployment\n */\nabstract contract IHomeFi is\n    ERC2771ContextUpgradeable,\n    ERC721URIStorageUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    modifier onlyAdmin() {\n        require(admin == _msgSender(), \"HomeFi::!Admin\");\n        _;\n    }\n\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"HomeFi::0 address\");\n        _;\n    }\n\n    /// VARIABLES ///\n    address public wrappedNativeCurrency;\n    address public tokenCurrency1;\n    address public tokenCurrency2;\n\n    IEvents public eventsInstance;\n    IProjectFactory public projectFactoryInstance;\n    address public disputeContract;\n    address public communityContract;\n\n    address public admin;\n    address public treasury;\n    uint256 public builderFee;\n    uint256 public investorFee;\n    mapping(uint256 => address) public projects;\n    mapping(address => bool) public projectExist;\n\n    mapping(address => uint256) public projectTokenId;\n\n    mapping(address => address) public wrappedToken;\n\n    uint256 public projectCount;\n    bool public addrSet;\n    uint256 public tokenCount;\n    address public trustedForwarder;\n\n    /**\n     * @notice checks trustedForwarder on HomeFi contract\n     * @param _forwarder address of contract forwarding meta tx\n     */\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return trustedForwarder == _forwarder;\n    }\n\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        //this is same as ERC2771ContextUpgradeable._msgSender();\n        //We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        //this is same as ERC2771ContextUpgradeable._msgData();\n        //We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n\n    /**\n     * @notice initialize this contract with required parameters.\n     * @dev modifier initializer\n     * @param _treasury rigor address which will receive builderFee and investorFee of rigor system\n     * @param _builderFee percentage of fee builder have to pay to rigor system\n     * @param _investorFee percentage of fee investor have to pay to rigor system\n     * @param _wrappedNativeCurrency address - WETH token address\n     * @param _tokenCurrency1 address - DAI token address\n     * @param _tokenCurrency2 address - USDC token address\n     */\n    function initialize(\n        address _treasury,\n        uint256 _builderFee,\n        uint256 _investorFee,\n        address _wrappedNativeCurrency,\n        address _tokenCurrency1,\n        address _tokenCurrency2,\n        address _forwarder\n    ) external virtual;\n\n    /**\n     * Pass addresses of other deployed modules into the HomeFi contract\n     * @dev can only be called once\n     * @param _eventsContract address - contract address of Events.sol\n     * @param _projectFactory contract address of ProjectFactory.sol\n     * @param _communityContract contract address of Community.sol\n     * @param _disputeContract contract address of Dispute.sol\n     * @param _hWrappedNative Wrapped Native currency debt token address\n     * @param _hTokenCurrency1 Token 1 debt token address\n     * @param _hTokenCurrency2 Token 2 debt token address\n     */\n    function setAddr(\n        address _eventsContract,\n        address _projectFactory,\n        address _communityContract,\n        address _disputeContract,\n        address _hWrappedNative,\n        address _hTokenCurrency1,\n        address _hTokenCurrency2\n    ) external virtual;\n\n    /**\n     * @dev to validate the currency is supported by HomeFi or not\n     * @param _currency currency address\n     */\n    function validCurrency(address _currency) public view virtual;\n\n    /// ADMIN MANAGEMENT ///\n    /**\n     * @notice only called by admin\n     * @dev replace admin\n     * @param _newAdmin new admin address\n     */\n    function replaceAdmin(address _newAdmin) external virtual;\n\n    /**\n     * @notice only called by admin\n     * @dev address which will receive HomeFi builder and investor fee\n     * @param _treasury new treasury address\n     */\n    function replaceTreasury(address _treasury) external virtual;\n\n    /**\n     * @notice this is only called by admin\n     * @dev to reset the builder and investor fee for HomeFi deployment\n     * @param _builderFee percentage of fee builder have to pay to HomeFi treasury\n     * @param _investorFee percentage of fee investor have to pay to HomeFi treasury\n     */\n    function replaceNetworkFee(uint256 _builderFee, uint256 _investorFee)\n        external\n        virtual;\n\n    /// PROJECT ///\n    /**\n     * @dev to create a project\n     * @param _hash IPFS hash of project details\n     * @param _currency address of currency which this project going to use\n     */\n    function createProject(bytes memory _hash, address _currency)\n        external\n        virtual;\n\n    /**\n     * @notice only called by admin\n     * @dev replace trustedForwarder\n     * @param _newForwarder new forwarder address\n     */\n    function setTrustedForwarder(address _newForwarder) external virtual;\n\n    /**\n     * @dev make every project NFT\n     * @param _to to which user this NFT belong to first time it will builder\n     * @param _tokenURI ipfs hash of project which contain project details like name, description etc.\n     * @return _tokenIds NFT Id of project\n     */\n    function mintNFT(address _to, string memory _tokenURI)\n        internal\n        virtual\n        returns (uint256);\n}\n",
            "keccak256": "0x92177150f48450266b16741f7ba4d5d6f374854f659d6db53e1f275a39f95dae",
            "license": "UNLICENSED"
        },
        "contracts/interfaces/IProject.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./IToken20.sol\";\nimport \"./IDisputes.sol\";\nimport \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport \"../libraries/SignatureDecoder.sol\";\nimport \"./IWrapped.sol\";\nimport \"../libraries/Tasks.sol\";\n\n/**\n * HomeFI v0.1.0 Deployable Project Escrow Contract Interface\n *\n * Interface for child contract from HomeFi service contract; escrows all funds\n * Use task library to store hashes of data within project\n */\nabstract contract IProject is\n    ERC2771ContextUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    // struct to store phase related details\n    struct Phase {\n        uint256 phaseCost;\n        uint256[] phaseToTaskList;\n        bool paid;\n    }\n\n    // Fixed //\n\n    // HomeFi NFT contract instance\n    IHomeFi public homeFi;\n\n    // Event contract instance\n    IEvents internal eventsInstance;\n\n    // Dispute contract instance\n    address internal disputes;\n\n    // Address of project currency\n    IToken20 public currency;\n\n    // builder fee inherited from HomeFi\n    uint256 public builderFee;\n\n    // investor fee inherited from HomeFi\n    uint256 public investorFee;\n\n    // address of builder\n    address public builder;\n\n    // Variable //\n\n    // address of invited contractor\n    address public contractor;\n\n    // bool that indicated if contractor has accepted invite\n    bool public contractorConfirmed;\n\n    // nonce that is used for signature security related to hash change\n    uint256 public hashChangeNonce;\n\n    // total amount invested in project\n    uint256 public totalInvested;\n\n    // total amount allocated in project\n    uint256 public totalAllocated;\n\n    // phase count of project. starts from 1.\n    uint256 public phaseCount;\n\n    // task count/serial. Starts from 1.\n    uint256 public taskCount;\n\n    // the index in nonFundedPhase from which phases are not funded\n    uint256 internal nonFundedCounter;\n\n    // array of phase index that are non funded.\n    uint256[] internal nonFundedPhase;\n\n    // sorted array of phase with non funded tasks\n    uint256[] internal nonFundedTaskPhases;\n\n    // mapping for each index of nonFundedTaskPhases to array of non funded task indexes.\n    mapping(uint256 => uint256[]) internal nonFundedPhaseToTask;\n\n    // mapping of phase index to Phase struct\n    mapping(uint256 => Phase) public phases;\n\n    // mapping of tasks index to Task struct.\n    mapping(uint256 => Task) public tasks;\n\n    /// MODIFIERS ///\n    /**\n     * @notice initialize this contract with required parameters. This is initialized by HomeFi contract\n     * @dev modifier initializer\n     * @param _currency currency address for this project\n     * @param _sender address of the creator / builder for this project\n     * @param _homeFiAddress address of the HomeFi contract\n     */\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external virtual;\n\n    /**\n     * @notice Contractor with fee schedule can be added to project\n     * @dev nonReentrant\n     * @param _data bytes encoded from-\n     * - address _contractor: address of project contractor\n     * - uint256[] _phaseCosts: array where each element represent phase cost, length of this array is number of phase to be added\n     * - address _projectAddress this project address, for signature security\n     */\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual;\n\n    /**\n     * @notice update project ipfs hash with adequate signatures.\n     * @dev If contractor is approved then both builder and contractor signature needed. Else only builder's.\n     * @param _data bytes encoded from-\n     * - bytes _hash bytes encoded ipfs hash.\n     * - uint256 _nonce current hashChangeNonce\n     * @param _signature bytes representing signature on _data by required members.\n     */\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual;\n\n    /**\n     * @notice change order to add phases in project. signature of both builder and contractor required.\n     * @dev modifier contractorAccepted.\n     * @param _data bytes encoded from-\n     * - uint256[] _phaseCosts array where each element represent phase cost, length of this array is number of phase to be added\n     * - uint256 _phaseCount current phase count, for signature security\n     * - address _projectAddress this project address, for signature security\n     * @param _signature bytes representing signature on _data by builder and contractor.\n     */\n    function addPhasesGC(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual;\n\n    /**\n     * @notice change order to change cost of existing phases. signature of both builder and contractor required.\n     * @dev modifier contractorAccepted.\n     * @param _data bytes encoded from-\n     * - uint256[] _phaseList array of phase indexes that needs to be updated\n     * - uint256[] _phaseCosts cost that needs to be updated for each phase index in _phaseList\n     * - address _projectAddress this project address, for signature security\n     * @param _signature bytes representing signature on _data by builder and contractor.\n     */\n    function changeCostGC(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual;\n\n    /**\n     * @notice release phase payment of a contractor\n     * @dev modifier contractorAccepted\n     * @param _phaseID the phase index for which the payment needs to be released\n     */\n    function releaseFeeContractor(uint256 _phaseID) external virtual;\n\n    /**\n     * @notice allows investing in the project, also funds 50 phase and tasks. If the project currency is ERC20 token,\n     * then before calling this function the sender must approve the tokens to this contract.\n     * @dev If the project's currency is native, then user can also pay in the native currency\n     * @dev by passing msg.value, it will be converted in to wrapped tokens internally\n     * @dev can only be called by builder or community contract(via investor).\n     * @param _cost the cost that is needed to be invested\n     */\n    function investInProject(uint256 _cost) external payable virtual;\n\n    // Task-Specific //\n\n    /**\n     * @notice adds tasks in a particular phase. Needs both builder and contractor signature.\n     * @dev contractor must be approved.\n     * @param _data bytes encoded from-\n     * - uint256 _phaseID phase number in which tasks are added\n     * - bytes[] _hash bytes ipfs hash of task details\n     * - uint256[] _cost an array of cost for each task index\n     * - address[] _sc an array subcontractor address for each task index\n     * - uint256 _taskCount current task count before adding these tasks. Can be fetched by taskCount.\n     *   For signature security.\n     * - address _projectAddress the address of this contract. For signature security.\n     * @param _signature bytes representing signature on _data by builder and contractor.\n     */\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual;\n\n    /**\n     * @dev If subcontractor is approved then builder, contractor and subcontractor signature needed.\n     * Else only builder and contractor.\n     * @notice update ipfs hash for a particular task\n     * @param _data bytes encoded from-\n     * - bytes[] _hash bytes ipfs hash of task details\n     * - uint256 _nonce current hashChangeNonce\n     * - uint256 _taskID task index\n     * @param _signature bytes representing signature on _data by required members.\n     */\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual;\n\n    /**\n     * @notice invite subcontractors for existing tasks. This can be called by builder or contractor.\n     * @dev this function internally calls _inviteSC.\n     * _taskList must not have a task which already has approved subcontractor.\n     * @param _taskList array the task index for which subcontractors needs to be assigned.\n     * @param _scList array of addresses of subcontractor for the respective task index.\n     */\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        virtual;\n\n    /**\n     * @notice invite subcontractors for a single task. This can be called by builder or contractor.\n     * @dev invite subcontractors for a single task. This can be called by builder or contractor.\n     * _taskList must not have a task which already has approved subcontractor.\n     * @param _task uint256 task index\n     * @param _sc address addresses of subcontractor for the respective task\n     * @param _emitEvent whether to emit event for each sc added or not\n     */\n    function _inviteSC(\n        uint256 _task,\n        address _sc,\n        bool _emitEvent\n    ) internal virtual;\n\n    /**\n     * @notice accept invite as subcontractor for a particular task.\n     * Only subcontractor invited can call this.\n     * @dev subcontractor must be unapproved.\n     * @param _taskList the task list of indexes for which sender wants to accept invite.\n     */\n    function acceptInviteSC(uint256[] calldata _taskList) external virtual;\n\n    /**\n     * @notice mark a task a complete and release subcontractor payment.\n     * Needs builder,contractor and subcontractor signature.\n     * @dev task must be in active state.\n     * @param _data bytes encoded from-\n     * - uint256 _taskID the index of task\n     * - address _projectAddress the address of this contract. For signature security.\n     * @param _signature bytes representing signature on _data by builder,contractor and subcontractor.\n     */\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual;\n\n    /**\n     * @notice checks trustedForwarder on HomeFi contract\n     * @param _forwarder address of contract forwarding meta tx\n     */\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /**\n     * @notice allocates funds for unallocated tasks and phases, and mark them as funded.\n     * @dev this is by default called by investInProject.\n     * But when unallocated task/phase count are beyond 50 then this is needed to be called externally.\n     */\n    function fundProject() public virtual;\n\n    /**\n     * @notice recover any amount sent mistakenly to this contract. Funds are transferred to builder account.\n     * If _tokenAddress is equal to this project currency, then we will first check is\n     * all the phases are complete.\n     * @dev If _tokenAddress is equal to this project currency, then we will first check is\n     * all the phases are complete\n     * @param _tokenAddress - address address for the token user wants to recover.\n     */\n    function recoverTokens(address _tokenAddress) external virtual;\n\n    /**\n     * @notice change order to change a task's subcontractor, cost or both.\n     * Needs builder,contractor and subcontractor signature.\n     * @param _data bytes encoded from-\n     * - uint256 _phaseID index of phase in which the task is present\n     * - uint256 _taskID index of the task\n     * - address _newSC address of new subcontractor.\n     *   If do not want to replace subcontractor, then pass address of existing subcontractor.\n     * - uint256 _newCost new cost for the task.\n     *   If do not want to change cost, then pass existing cost.\n     * - address _project address of project\n     * @param _signature bytes representing signature on _data by builder,contractor and subcontractor.\n     */\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual;\n\n    /**\n     * Raise a dispute to arbitrate & potentially enforce requested state changes\n     * @dev prolly reentrant\n     *\n     * @param _data bytes\n     *   - 0: project address, 1: task id (0 if none), 2: action type, 3: action data, 5: ipfs cid of pdf\n     *   - const types = [\"address\", \"uint256\", \"uint8\", \"bytes\", \"bytes\"]\n     * @param _signature bytes - hash of _data signed by the address raising dispute\n     */\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        returns (uint256);\n\n    /**\n     * @dev transfer excess funds back to builder wallet.\n     * Called internally-\n     * 1. Change in already funded phases with lower overall cost\n     * 2. Phase changeOrder when new phase cost is lower than older cost\n     * 3. Task changeOrder when new task cost is lower than older cost\n     * @param _amount uint256 - amount of excess fund\n     */\n    function autoWithdraw(uint256 _amount) internal virtual;\n\n    /**\n     * @dev transfer funds to contractor or subcontract, on completion of phase or task respectively.\n     */\n    function payFee(address _recipient, uint256 _amount) internal virtual;\n\n    /// VIEWABLE FUNCTIONS ///\n\n    /**\n     * @notice returns Lifecycle statuses of a task\n     * @param _taskID task index\n     * @return _alerts bool[3] array of bool representing whether Lifecycle alert has been reached.\n     * Lifecycle alerts- [None, TaskFunded, SCConfirmed]\n     */\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        virtual\n        returns (bool[3] memory _alerts);\n\n    /**\n     * @notice returns cost of project. Cost of project is sum of phase and task costs.\n     * @return _cost uint256 cost of project.\n     */\n    function projectCost() external view virtual returns (uint256 _cost);\n\n    /**\n     * @notice returns tasks index array in a phase.\n     * @param _phaseID phase index for fetching tasks\n     * @return _taskList uint256[] task indexes.\n     */\n    function getPhaseToTaskList(uint256 _phaseID)\n        external\n        view\n        virtual\n        returns (uint256[] memory _taskList);\n\n    /**\n     * @dev returns address recovered from _data and _signature\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _count number of addresses to recover\n     * @return _recoveredArray address[3] array of recovered address\n     */\n    function recoverAddresses(\n        bytes memory _data,\n        bytes memory _signature,\n        uint256 _count\n    ) internal pure virtual returns (address[3] memory _recoveredArray);\n\n    /**\n     * @dev check if recovered signatures match with builder and contractor address.\n     * reverts if signature do not match.\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     */\n    function checkSignature(bytes calldata _data, bytes calldata _signature)\n        internal\n        view\n        virtual;\n\n    /**\n     * @dev check if recovered signatures match with builder, contractor and subcontractor address for a task.\n     * reverts if signatures do not match.\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _taskID index of the task.\n     */\n    function checkSignatureTask(\n        bytes calldata _data,\n        bytes calldata _signature,\n        uint256 _taskID\n    ) internal view virtual;\n\n    /**\n     * @dev Insertion Sort, in ascending order.\n     * @param arr_ uint256[] array needed to be sorted.\n     * @return _arr uint256[] array sorted in ascending order.\n     */\n    function sortArray(uint256[] memory arr_)\n        internal\n        pure\n        virtual\n        returns (uint256[] memory);\n\n    /**\n     * @dev check if precision is greater than 1000, if so it reverts\n     * @param _amount amount needed to be checked for precision.\n     */\n    function checkPrecision(uint256 _amount) internal pure virtual;\n\n    /**\n     * @dev returns the amount after adding builder fee\n     * @param _amount amount to upon which builder fee is taken\n     */\n    function _costWithBuilderFee(uint256 _amount)\n        internal\n        view\n        virtual\n        returns (uint256 _amountWithFee);\n}\n",
            "keccak256": "0x1684fa8c6334d97ec1fba0efe089f39066c269e85163282d409da9f773b2acbc",
            "license": "UNLICENSED"
        },
        "contracts/interfaces/IToken20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface of the ERC20 standard with mint & burn methods\n */\ninterface IToken20 is IERC20Upgradeable {\n    /**\n     * Create new tokens and sent to an address\n     *\n     * @param _to address - the address receiving the minted tokens\n     * @param _total uint256 - the amount of tokens to mint to _to\n     */\n    function mint(address _to, uint256 _total) external;\n\n    /**\n     * Destroy tokens at an address\n     *\n     * @param _to address - the address where tokens are burned from\n     * @param _total uint256 - the amount of tokens to burn from _to\n     */\n    function burn(address _to, uint256 _total) external;\n}\n",
            "keccak256": "0x5705494ad57aebdb7cd60eb41a05603a77dd81e441adf27451c5720919c4db1b",
            "license": "MIT"
        },
        "contracts/interfaces/IWrapped.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\ninterface IWrapped is IERC20Upgradeable, IERC20MetadataUpgradeable {\n    // brief interface for canonical native token wrapper contract\n    function deposit() external payable;\n}\n",
            "keccak256": "0x57b2f4cc3c067155eb7af7f5d75835137eb3d29db1660274324885155fcfd9a4",
            "license": "UNLICENSED"
        },
        "contracts/libraries/SignatureDecoder.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n\nlibrary SignatureDecoder {\n    /// @dev Recovers address who signed the message\n    /// @param messageHash keccak256 hash of message\n    /// @param messageSignatures concatenated message signatures\n    /// @param pos which signature to read\n    function recoverKey(\n        bytes32 messageHash,\n        bytes memory messageSignatures,\n        uint256 pos\n    ) internal pure returns (address) {\n        if (messageSignatures.length % 65 != 0) {\n            return (address(0));\n        }\n\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignatures, pos);\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            // solium-disable-next-line arg-overflow\n            return ecrecover(toEthSignedMessageHash(messageHash), v, r, s);\n        }\n    }\n\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n            );\n    }\n\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            v := byte(0, mload(add(signatures, add(signaturePos, 0x60))))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n    }\n}\n",
            "keccak256": "0xee1107f828458f70b6845b707b37fdd989f2b7250729b31e458c7ca85816d626",
            "license": "UNLICENSED"
        },
        "contracts/libraries/Tasks.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nlibrary Tasks {\n    /// MODIFIERS ///\n\n    /// @dev only allow inactive tasks. Task are inactive if SC is unconfirmed.\n    modifier onlyInactive(Task storage _self) {\n        require(_self.state == TaskStatus.Inactive, \"Task::active\");\n        _;\n    }\n\n    /// @dev only allow active tasks. Task are inactive if SC is confirmed.\n    modifier onlyActive(Task storage _self) {\n        require(_self.state == TaskStatus.Active, \"Task::!Active\");\n        _;\n    }\n\n    /// @dev only allow funded tasks.\n    modifier onlyFunded(Task storage _self) {\n        require(_self.alerts[uint256(Lifecycle.TaskFunded)], \"Task::!funded\");\n        _;\n    }\n\n    /// MUTABLE FUNCTIONS ///\n\n    // Task Status Changing Functions //\n\n    /**\n     * Create a new Task object\n     * @dev cannot operate on initialized tasks\n     * @param _self Task the task struct being mutated\n     * @param _cost uint the number of tokens to be escrowed in this contract\n     */\n    function initialize(Task storage _self, uint256 _cost) public {\n        _self.cost = _cost;\n        _self.state = TaskStatus.Inactive;\n        _self.alerts[uint256(Lifecycle.None)] = true;\n    }\n\n    /**\n     * Attempt to transition task state from Payment Pending to Complete\n     * @dev modifier onlyActive\n     * @param _self Task the task whose state is being mutated\n     */\n    function setComplete(Task storage _self)\n        internal\n        onlyActive(_self)\n        onlyFunded(_self)\n    {\n        // State/ Lifecycle //\n        _self.state = TaskStatus.Complete;\n    }\n\n    // Subcontractor Joining //\n\n    /**\n     * Invite a subcontractor to the task\n     * @dev modifier onlyInactive\n     * @param _self Task the task being joined by subcontractor\n     * @param _sc address the subcontractor being invited\n     */\n    function inviteSubcontractor(Task storage _self, address _sc)\n        internal\n        onlyInactive(_self)\n    {\n        _self.subcontractor = _sc;\n    }\n\n    /**\n     * As a subcontractor, accept an invitation to participate in a task.\n     * @dev modifier onlyInactive\n     * @param _self Task the task being joined by subcontractor\n     * @param _sc Address of sender\n     */\n    function acceptInvitation(Task storage _self, address _sc)\n        internal\n        onlyInactive(_self)\n    {\n        // Prerequisites //\n        require(_self.subcontractor == _sc, \"Task::!SC\");\n\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.SCConfirmed)] = true;\n        _self.state = TaskStatus.Active;\n    }\n\n    // Task Funding //\n\n    /**\n     * Set a task as funded\n     * @param _self Task the task being set as funded\n     */\n    function fundTask(Task storage _self) internal {\n        // State/ Lifecycle //\n        _self.alerts[uint256(Lifecycle.TaskFunded)] = true;\n    }\n\n    /**\n     * Set a task as un-funded\n     * @param _self Task the task being set as funded\n     */\n    function unFundTask(Task storage _self) internal {\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.TaskFunded)] = false;\n    }\n\n    /**\n     * Set a task as un accepted/approved for SC\n     * @dev modifier onlyActive\n     * @param _self Task the task being set as funded\n     */\n    function unApprove(Task storage _self) internal {\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.SCConfirmed)] = false;\n        _self.state = TaskStatus.Inactive;\n    }\n\n    /// VIEWABLE FUNCTIONS ///\n\n    /**\n     * Determine the current state of all alerts in the project\n     * @param _self Task the task being queried for alert status\n     * @return _alerts bool[3] array of bool representing whether Lifecycle alert has been reached\n     */\n    function getAlerts(Task storage _self)\n        internal\n        view\n        returns (bool[3] memory _alerts)\n    {\n        for (uint256 i = 0; i < _alerts.length; i++)\n            _alerts[i] = _self.alerts[i];\n    }\n\n    /**\n     * Return the numerical encoding of the TaskStatus enumeration stored as state in a task\n     * @param _self Task the task being queried for state\n     * @return _state uint 0: none, 1: inactive, 2: active, 3: complete\n     */\n    function getState(Task storage _self)\n        internal\n        view\n        returns (uint256 _state)\n    {\n        return uint256(_self.state);\n    }\n}\n\n// Task metadata\nstruct Task {\n    // Metadata //\n    uint256 cost;\n    address subcontractor;\n    // Lifecycle //\n    TaskStatus state;\n    mapping(uint256 => bool) alerts;\n}\n\nenum TaskStatus {\n    None,\n    Inactive,\n    Active,\n    Complete\n}\n\nenum Lifecycle {\n    None,\n    TaskFunded,\n    SCConfirmed\n}\n",
            "keccak256": "0xc5fd315ec576a0a0a6ce8ce3ad86c750d7b48d42d015676167649a135d0ff373",
            "license": "UNLICENSED"
        }
    },
    "version": 1
}